// Emacs style mode select   -*- C++ -*- 
//-----------------------------------------------------------------------------
//
// $Id:$
//
// Copyright (C) 1993-1996 by id Software, Inc.
//
// This source is available for distribution and/or modification
// only under the terms of the DOOM Source Code License as
// published by id Software. All rights reserved.
//
// The source is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License
// for more details.
//
// $Log:$
//
// DESCRIPTION:
//	DOOM graphics stuff for Nspire
//
//-----------------------------------------------------------------------------

#include "os.h"

#include "doomstat.h"
#include "i_system.h"
#include "v_video.h"
#include "d_main.h"

#include "doomdef.h"


//Pallette data
//High byte: 4 MSBs declare B
//Low  byte: 4 LSBs declare R
//Theoretically, we COULD have saved it in the WAD file somewhere, but fuck that
//Hardcoded = Awesome
//short = 2 bytes = 16 bits = palette word length


static const unsigned short gwPallette[256]=
{
0x0000,0x18A1,0x1060,0x4A49,0xFFFF,0x18C3,0x1082,0x0841,0x0020,0x29A3,0x2141,0x10E0,0x08A0,0x49C5,0x4184,0x3943,
0xFDB6,0xF555,0xF514,0xECB2,0xE471,0xDC30,0xDBCF,0xD38E,0xCB4D,0xC30C,0xBACB,0xBAAA,0xB269,0xAA28,0xA1E7,0xA1C7,
0x9986,0x9165,0x8945,0x8904,0x80E3,0x78C3,0x70A2,0x7082,0x6861,0x6041,0x5820,0x5820,0x5020,0x4800,0x4000,0x4000,
0xFF5B,0xFF1A,0xFED8,0xFE97,0xFE76,0xFE34,0xFDF3,0xFDD2,0xFD90,0xF54F,0xED0E,0xE4CD,0xDC8C,0xD44B,0xCC0A,0xCBE9,
0xBBC9,0xB388,0xAB68,0xA347,0x9B07,0x8AE6,0x82A6,0x7A85,0x7265,0x6A24,0x5A04,0x51E3,0x49A3,0x3962,0x3142,0x2901,
0xEF7D,0xE73C,0xDEFB,0xDEDB,0xD69A,0xCE59,0xC638,0xBDF7,0xB5B6,0xB596,0xAD55,0xA534,0x9CF3,0x94B2,0x9492,0x8C51,
0x8410,0x7BEF,0x73AE,0x6B6D,0x6B4D,0x630C,0x5ACB,0x52AA,0x4A69,0x4228,0x4208,0x39C7,0x31A6,0x2965,0x2124,0x2104,
0x77ED,0x6F6C,0x66EB,0x5E6A,0x5DE9,0x5568,0x4CE7,0x4486,0x3C05,0x3385,0x2B04,0x2283,0x1A02,0x1181,0x1101,0x08A0,
0xBD31,0xB4F0,0xACAF,0xA46E,0x9C2D,0x9BED,0x93CC,0x8B8B,0x834A,0x7B09,0x72E9,0x6AA8,0x6287,0x5A46,0x5206,0x51E5,
0x9C0C,0x8BAA,0x8349,0x72E7,0x6286,0x5A25,0x49C4,0x4183,0x7BEC,0x6B8A,0x6349,0x5B08,0x52A7,0x4266,0x3A25,0x31E4,
0xFFEE,0xEECA,0xD5C8,0xC4C5,0xABC3,0x9AC2,0x8200,0x7140,0xFFFF,0xFEDB,0xFDD7,0xFCD3,0xFBCF,0xFAEB,0xF9E7,0xF8E3,
0xF800,0xE800,0xE000,0xD000,0xC800,0xB800,0xB000,0xA000,0x9800,0x8800,0x7800,0x7000,0x6000,0x5800,0x4800,0x4000,
0xE73F,0xC63F,0xAD5F,0x8C7F,0x739F,0x529F,0x31BF,0x18DF,0x001F,0x001C,0x0019,0x0016,0x0013,0x0010,0x000D,0x000A,
0xFFFF,0xFF5B,0xFEB7,0xFE33,0xFD8F,0xFD0B,0xFC67,0xFBE3,0xF382,0xEB61,0xDB21,0xD2E1,0xCAA0,0xC260,0xB220,0xAA00,
0xFFFF,0xFFFA,0xFFF6,0xFFF1,0xFFED,0xFFE8,0xFFE4,0xFFE0,0xA1E0,0x99A0,0x9160,0x8100,0x49C4,0x4163,0x3102,0x28C1,
0x000A,0x0008,0x0007,0x0005,0x0004,0x0002,0x0001,0x0000,0xFCE8,0xFF29,0xFBDF,0xF81F,0xC819,0x9813,0x680D,0xA34D
};

//#ifndef CG_EMULATOR
#if 0 // this doesn't work

//#define SYNCO() __asm__ volatile("SYNCO\n\t":::"memory"); //doesn't compile
#define SYNCO()
#define PRDR *(volatile unsigned char *)0xA405013C
#define LCDC *(volatile unsigned short*)0xB4000000

#define LCD_GRAM_X 0x200
#define LCD_GRAM_Y 0x201
#define LCD_GRAM 0x202
#define LCD_WINDOW_LEFT 0x210
#define LCD_WINDOW_RIGHT 0x211
#define LCD_WINDOW_TOP 0x212
#define LCD_WINDOW_BOTTOM 0x213

static void SelectLCDReg(unsigned short reg)
{
   SYNCO();
   PRDR &= ~0x10;
   SYNCO();
   LCDC = reg;
   SYNCO();
   PRDR |= 0x10;
   SYNCO();
   return;
}

static void WriteLCDReg(unsigned short reg, unsigned short value)
{
   SelectLCDReg(reg);
   LCDC = value;
   return;
}

static unsigned short ReadLCDReg(unsigned short reg)
{
   SelectLCDReg(reg);
   return LCDC;
}

void I_Flip (void)
{
  unsigned j=0,i = 320*200;
  while(i--)
  {
    LCDC = gwPallette[screens[0][j]];
    j++;
  }
}

void I_InitGraphics(void)
{	
  WriteLCDReg(LCD_WINDOW_LEFT, (396 - 320)/2);
  WriteLCDReg(LCD_WINDOW_RIGHT, (396 - 320)/2 + 319);
  WriteLCDReg(LCD_WINDOW_TOP, (224 - 200) / 2);
  WriteLCDReg(LCD_WINDOW_BOTTOM, (224 - 200) / 2 + 199);
}

void I_ShutdownGraphics(void)
{

  WriteLCDReg(LCD_WINDOW_LEFT, (396 - 384)/2);
   WriteLCDReg(LCD_WINDOW_RIGHT, (396 - 384)/2 + 383);
   WriteLCDReg(LCD_WINDOW_TOP, (224 - 216) / 2);
   WriteLCDReg(LCD_WINDOW_BOTTOM, (224 - 216) / 2 + 215);
}
#else

void I_Flip (void)
{
  int x,y;
  for(y=0;y<SCREENHEIGHT;y++)
  {
    for(x=0;x<SCREENWIDTH;x++)
    {
      VRAM[(x+(WIDTH-SCREENWIDTH)/2)+(y+(HEIGHT-SCREENHEIGHT)/2)*WIDTH] = gwPallette[screens[0][x+y*SCREENWIDTH]];
    }
  }
  Bdisp_PutDisp_DD();
}

void I_InitGraphics(void)
{	
}

void I_ShutdownGraphics(void)
{

}

#endif
